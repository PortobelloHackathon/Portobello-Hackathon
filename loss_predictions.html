<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portobello Dashboard — Predictive (Client-only, auto-load ml_model.joblib)</title>

  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter','ui-sans-serif','system-ui'] },
          colors: {
            pbBlue: '#0B1F52',
            pbSlate: '#6B7280',
            pbGrayLight: '#CFD3DA',
            pbGrayMid:   '#7C8390',
            pbGrayDark:  '#434A52',
            stageActual: '#16A34A',  // green
            stagePred:   '#F4B000',  // yellow
          }
        }
      }
    }
  </script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- Pyodide (Python in the browser) -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>

<body class="h-screen flex flex-col bg-slate-50 text-slate-800 font-sans">
  <!-- HEADER -->
  <header class="bg-gradient-to-r from-pbGrayLight via-pbGrayMid/80 to-pbBlue">
    <div class="relative w-full py-5 pl-3 flex items-center">
      <!-- Left: Logo with tiny left padding -->
      <a href="/" class="shrink-0">
        <img
          src="assets/images/logo_portobello_america_CORES_pantone_655.png"
          alt="Portobello America"
          class="h-16 w-auto object-contain block"
        />
      </a>

      <!-- Center: Title (stays perfectly centered regardless of logo width) -->
      <h1
        class="absolute left-1/2 -translate-x-1/2 text-white text-xl md:text-2xl lg:text-4xl font-semibold tracking-tight text-center pointer-events-none"
      >
        Tile Material Dashboard
      </h1>

      <!-- Right: Spacer for symmetry / future actions -->
      <div class="ml-auto"></div>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden">
    <script src="sidebar.js" defer></script>

    <!-- MAIN -->
    <main class="flex-1 overflow-auto">
      <div class="mx-auto max-w-7xl px-8 py-8">
        <!-- ======== PANEL: PREDICTIONS (active) ======== -->
        <section id="panel-predictions">
          <h2 class="text-3xl font-semibold tracking-tight text-slate-900">Predictions</h2>

          <!-- TOP STATUS -->
          <section class="mt-5 rounded-2xl border border-slate-200 bg-white shadow-sm p-4">
            <div class="flex flex-wrap items-start gap-3 justify-between">
              <div>
                <h3 class="text-lg font-semibold text-slate-800">Model & Inputs</h3>
                <p id="statusText" class="text-sm text-slate-500 mt-1">Booting Python…</p>
                <details class="mt-2 text-xs text-slate-500">
                  <summary class="cursor-pointer select-none">Debug</summary>
                  <pre id="debugLog" class="mt-2 bg-slate-50 border rounded p-2 whitespace-pre-wrap"></pre>
                </details>
              </div>
              <div class="flex items-center gap-2">
                <button id="btnExample"   class="px-3 py-1.5 rounded border">Example</button>
                <button id="btnReset"     class="px-3 py-1.5 rounded border">Reset</button>
                <button id="btnPredict"   class="px-3 py-1.5 rounded bg-pbBlue text-white font-semibold">Predict</button>
              </div>
            </div>
          </section>

          <!-- Inputs by Stage -->
          <section class="mt-4 rounded-2xl border border-slate-200 bg-white shadow-sm p-4">
            <div class="flex flex-wrap items-start gap-3 justify-between">
              <div>
                <h3 class="text-lg font-semibold text-slate-800">Inputs by Stage</h3>
                <p id="inputHint" class="text-sm text-slate-500 mt-1">Enter Start (required). Add actuals to lock a stage (green), or provide inputs to unlock predictions (yellow).</p>
              </div>
              <div class="flex items-center gap-2 text-xs text-slate-500">
                <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm" style="background:#16A34A"></span> Actual</span>
                <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm" style="background:#F4B000"></span> Predicted</span>
                <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm border border-slate-400" style="background:#fff"></span> Min (dashed)</span>
              </div>
            </div>

            <!-- Grid of inputs -->
            <div class="mt-4 grid grid-cols-12 gap-4">
              <!-- START -->
              <div class="col-span-12 md:col-span-3 rounded-xl border p-3">
                <div class="flex items-center justify-between mb-2">
                  <h4 class="font-semibold">Start</h4>
                  <span id="badgeStart" class="text-xs px-2 py-0.5 rounded bg-slate-100">blocked</span>
                </div>
                <label class="block text-sm mb-1">Datetime</label>
                <input id="datetime" type="datetime-local" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Recipe ID</label>
                <select id="recipe_id" class="w-full border rounded p-2 mb-2 bg-white">
                  <option value="">Choose…</option>
                  <option value="241">241</option>
                  <option value="244">244</option>
                  <option value="245">245</option>
                  <option value="246">246</option>
                  <option value="247">247</option>
                </select>
                <label class="block text-sm mb-1">Gloss Type</label>
                <input id="gloss_type" type="text" class="w-full border rounded p-2 mb-2" placeholder="e.g. shiny, matte" />
                <label class="block text-sm mb-1">Gloss Amount Target (g/tile)</label>
                <input id="gloss_amount_target_g_per_tile" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Start Volume</label>
                <input id="vol_start" type="number" class="w-full border rounded p-2" placeholder="required" />
              </div>
              <!-- PRESS -->
              <div class="col-span-12 md:col-span-3 rounded-xl border p-3">
                <div class="flex items-center justify-between mb-2">
                  <h4 class="font-semibold">Press</h4>
                  <span id="badgePress" class="text-xs px-2 py-0.5 rounded bg-slate-100">blocked</span>
                </div>
                <label class="block text-sm mb-1">Press Output (actual, optional)</label>
                <input id="vol_press_out" type="number" class="w-full border rounded p-2 mb-2" placeholder="if known, overrides model" />
                <label class="block text-sm mb-1">Target Pressure</label>
                <input id="target_pressure" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Actual Pressure</label>
                <input id="actual_pressure" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Layers Tossed</label>
                <input id="layers_tossed" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Desired Thickness</label>
                <input id="desired_thickness" type="number" class="w-full border rounded p-2 mb-2" />
              </div>
              <!-- GLAZE -->
              <div class="col-span-12 md:col-span-3 rounded-xl border p-3">
                <div class="flex items-center justify-between mb-2">
                  <h4 class="font-semibold">Glaze</h4>
                  <span id="badgeGlaze" class="text-xs px-2 py-0.5 rounded bg-slate-100">blocked</span>
                </div>
                <label class="block text-sm mb-1">Glaze Output (actual, optional)</label>
                <input id="vol_glaze_out" type="number" class="w-full border rounded p-2 mb-2" placeholder="if known, overrides model" />
                <label class="block text-sm mb-1">Recipe Air Cooling</label>
                <input id="recipe_air_cooling" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Recipe Moisture</label>
                <input id="recipe_moisture" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Recipe Air Flow</label>
                <input id="recipe_air_flow" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Recipe Max Temp</label>
                <input id="recipe_max_temp" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Recipe Humidity</label>
                <input id="recipe_humidity" type="number" class="w-full border rounded p-2 mb-2" />
              </div>
              <!-- KILN -->
              <div class="col-span-12 md:col-span-3 rounded-xl border p-3">
                <div class="flex items-center justify-between mb-2">
                  <h4 class="font-semibold">Kiln</h4>
                  <span id="badgeKiln" class="text-xs px-2 py-0.5 rounded bg-slate-100">blocked</span>
                </div>
                <label class="block text-sm mb-1">Kiln Output (actual, optional)</label>
                <input id="vol_kiln_out" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Kiln Air Cooling</label>
                <input id="kiln_air_cooling" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Kiln Moisture</label>
                <input id="kiln_moisture" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Kiln Air Flow</label>
                <input id="kiln_air_flow" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Kiln Max Temp</label>
                <input id="kiln_max_temp" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Kiln Humidity</label>
                <input id="kiln_humidity" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Delta Air Cooling</label>
                <input id="delta_air_cooling" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Delta Moisture</label>
                <input id="delta_moisture" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Delta Air Flow</label>
                <input id="delta_air_flow" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Delta Max Temp</label>
                <input id="delta_max_temp" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Delta Humidity</label>
                <input id="delta_humidity" type="number" class="w-full border rounded p-2 mb-2" />
                <label class="block text-sm mb-1">Sort Output (optional)</label>
                <input id="vol_sort_out" type="number" class="w-full border rounded p-2 mb-2" />
              </div>
            </div>
          </section>

          <!-- CHART -->
          <div class="mt-6 grid grid-cols-12 gap-4">
            <section class="col-span-12 rounded-2xl border border-slate-200 bg-white shadow-sm p-4 h-[24rem]">
              <div class="flex items-center justify-between mb-2">
                <h3 class="text-lg font-semibold text-slate-800">Material Loss Per Stage</h3>
                <div class="flex items-center gap-3 text-xs text-slate-500">
                  <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm" style="background:#16A34A"></span> Actual</span>
                  <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm" style="background:#F4B000"></span> Predicted</span>
                  <span class="inline-flex items-center gap-1"><span class="w-3 h-3 inline-block rounded-sm border border-slate-400" style="background:#fff"></span> Min (dashed)</span>
                </div>
              </div>
              <canvas id="lossLineChart" class="w-full h-full"></canvas>
            </section>
          </div>
        </section>

        <!-- ======== PANEL: ANALYTICS (placeholder) ======== -->
        <section id="panel-analytics" class="hidden">
          <h2 class="text-3xl font-semibold tracking-tight text-slate-900">Analytics</h2>
          <section class="mt-5 rounded-2xl border border-slate-200 bg-white shadow-sm p-6">
            <p class="text-slate-600">Analytics content goes here.</p>
          </section>
        </section>

        <!-- ======== PANEL: DATA (placeholder) ======== -->
        <section id="panel-data" class="hidden">
          <h2 class="text-3xl font-semibold tracking-tight text-slate-900">Data</h2>
          <section class="mt-5 rounded-2xl border border-slate-200 bg-white shadow-sm p-6">
            <p class="text-slate-600">Data tools go here.</p>
          </section>
        </section>
      </div>
    </main>
  </div>

<script>
  // ---------- Sidebar tab logic ----------
  const tabButtons = document.querySelectorAll('.tablink');
  const panels = {
    predictions: document.getElementById('panel-predictions'),
    analytics:   document.getElementById('panel-analytics'),
    data:        document.getElementById('panel-data'),
  };

  function setActiveTab(nameRaw){
    const name = (nameRaw || 'predictions').toLowerCase();
    const panel = panels[name] || panels['predictions'];

    // show/hide panels
    Object.values(panels).forEach(p => p && p.classList.add('hidden'));
    if (panel) panel.classList.remove('hidden');

    // button styles
    tabButtons.forEach(btn => {
      const isActive = (btn.dataset.tab || '').toLowerCase() === name;
      btn.className = 'tablink flex items-center px-5 py-3 rounded-r-full mb-2 transition ' +
        (isActive ? 'bg-[#0b1f52] text-white font-semibold shadow-sm'
                  : 'text-slate-700 hover:bg-slate-200');
      if (isActive) btn.setAttribute('aria-current','page'); else btn.removeAttribute('aria-current');
    });
  }

  tabButtons.forEach(btn => btn.addEventListener('click', () => setActiveTab(btn.dataset.tab)));
  setActiveTab('predictions');

  // ---------- Colors / Chart defaults ----------
  const PB_GRAY_D = '#434A52', PB_GRAY_L='#CFD3DA';
  const ACTUAL = '#16A34A', PRED='#F4B000', FUTURE='#0B1F52';
  const STAGES = ['Start','Press','Glaze','Kiln','Sort'];

  Chart.defaults.font.family = 'Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  Chart.defaults.color = PB_GRAY_D;
  Chart.defaults.plugins.legend.display = false;

  // Helpers
  const $ = id => document.getElementById(id);
  // Updated fields for new model schema
  const fields = [
    'datetime',
    'recipe_id',
    'gloss_type',
    'gloss_amount_target_g_per_tile',
    'vol_start',
    'vol_press_out',
    'vol_glaze_out',
    'vol_kiln_out',
    'vol_sort_out',
    'target_pressure',
    'actual_pressure',
    'layers_tossed',
    'desired_thickness',
    'recipe_air_cooling',
    'recipe_moisture',
    'recipe_air_flow',
    'recipe_max_temp',
    'recipe_humidity',
    'kiln_air_cooling',
    'kiln_moisture',
    'kiln_air_flow',
    'kiln_max_temp',
    'kiln_humidity',
    'delta_air_cooling',
    'delta_moisture',
    'delta_air_flow',
    'delta_max_temp',
    'delta_humidity'
  ];
  function setVal(id,v){
    const el = $(id);
    if(!el) return;
    if(el.tagName === 'SELECT'){
      el.value = (v==null||v==='') ? '' : String(v);
    }else{
      el.value = (v==null||Number.isNaN(v))?'':v;
    }
  }
  function logDebug(msg){
    const el = document.getElementById('debugLog');
    el.textContent += (typeof msg === 'string' ? msg : JSON.stringify(msg, null, 2)) + '\n';
    el.scrollTop = el.scrollHeight;
  }

  // ----- Line chart with tooltips (value + loss vs Start + min) -----
  let stageStatus = ['future','future','future','future','future'];
  let lastVols = [null,null,null,null,null];
  let lastMins = [null,null,null,null,null];
  function colorFor(i){ return stageStatus[i]==='actual'?ACTUAL:(stageStatus[i]==='pred'?PRED:FUTURE); }
  const fmt = n => (n==null||!isFinite(n)) ? '-' : n.toLocaleString();

  const lossLineChart = new Chart(document.getElementById('lossLineChart'), {
    type:'line',
    data:{
      labels: STAGES,
      datasets:[
        { // Volume
          label:'Volume',
          data:[null,null,null,null,null],
          borderWidth:2, tension:0.3, fill:false,
          segment:{ borderColor:(ctx)=>colorFor(ctx.p0DataIndex) },
          pointBackgroundColor:(ctx)=>colorFor(ctx.dataIndex),
          pointRadius:4, pointHoverRadius:6
        },
        { // Min Required (dashed)
          label:'Min Required',
          data:[null,null,null,null,null],
          borderWidth:1.5, borderDash:[6,6],
          borderColor:PRED, pointRadius:0, tension:0.3, fill:false
        }
      ]
    },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        x:{ grid:{ display:false } },
        y:{ beginAtZero:true, grid:{ color:PB_GRAY_L } }  // start at 0
      },
      plugins:{
        tooltip:{
          callbacks:{
            title:(items)=>{
              const i = items[0].dataIndex;
              return `Stage ${i+1} — ${STAGES[i]}`;
            },
            label:(item)=>{
              const i = item.dataIndex;
              const val = lastVols[i];
              const status = stageStatus[i]==='actual' ? 'Actual'
                            : stageStatus[i]==='pred'   ? 'Predicted'
                            : 'Future';
              if(val==null) return 'No data';
              return `Value: ${fmt(val)} ft² (${status})`;
            },
            afterLabel:(item)=>{
              const i = item.dataIndex;
              const start = lastVols[0];
              const val   = lastVols[i];
              const minV  = lastMins[i];
              if(start==null || val==null) return '';
              const loss  = Math.max(0, start - val);
              const pct   = start>0 ? (loss/start*100) : 0;
              const lines = [`Loss vs Start: ${fmt(loss)} ft² (${pct.toFixed(2)}%)`];
              if(minV!=null && stageStatus[i]==='pred'){
                lines.push(`Min Required: ${fmt(minV)} ft²`);
              }
              return '\n' + lines.join('\n');
            }
          }
        }
      }
    }
  });

  function updateChart(vols, mins, statuses){
    stageStatus = statuses.slice();
    lastVols = vols.slice();
    lastMins = mins.slice();
    lossLineChart.data.datasets[0].data = vols;
    lossLineChart.data.datasets[1].data = mins;
    lossLineChart.update();
  }

  // Badges
  function setBadges(states){
    const ids = ['badgeStart','badgePress','badgeGlaze','badgeKiln'];
    ids.forEach((id,i)=>{
      const st = states?states[i]:null;
      const txt = st?st:'blocked';
      const cls = st==='actual' ? 'bg-green-100 text-green-700'
               : st==='pred'   ? 'bg-amber-100 text-amber-700'
               : 'bg-slate-100 text-slate-600';
      const el = document.getElementById(id);
      el.textContent = txt; el.className = `text-xs px-2 py-0.5 rounded ${cls}`;
    });
  }

  function resetAll(){
    fields.forEach(f=> setVal(f,''));
    updateChart([null,null,null,null,null],[null,null,null,null,null],['future','future','future','future','future']);
    setBadges();
    $('inputHint').textContent='Enter Start → add actuals or inputs to unlock predictions.';
  }

  // ------------------- Pyodide + Auto-load model -------------------
  let pyodide, modelLoaded = false;
  const MODEL_PATH = '/tmp/ml_model.joblib';  // mounted copy in FS
  const MODEL_URL  = 'ml_model.joblib';       // must exist next to this HTML

  async function initPy(){
    $('statusText').textContent = 'Loading Python…';
    try{
      pyodide = await loadPyodide();
      try { await pyodide.loadPackage(['numpy','pandas','scikit-learn','joblib']); }
      catch(e){ console.warn('Package load warning:', e); logDebug(e.toString()); }
      const pyCode = `
import math, json, numpy as np, pandas as pd, joblib
bundle=None
press_model=glaze_model=kiln_model=None
stage_features={}
recipe_setpoints={}
THRESH_MARGIN=0.03
SORT_MIN=0.90
SORT_DEFAULT=0.90
SORT_MAX=0.92

def load_model(path):
    global bundle, press_model, glaze_model, kiln_model, THRESH_MARGIN, SORT_MIN, SORT_DEFAULT, SORT_MAX, stage_features, recipe_setpoints
    bundle = joblib.load(path)
    if isinstance(bundle, dict) and "models" in bundle:
        press_model = bundle["models"]["press_ratio"]
        glaze_model = bundle["models"]["glaze_ratio"]
        kiln_model  = bundle["models"]["kiln_ratio"]
        stage_features = bundle.get("stage_features", {})
        recipe_setpoints = bundle.get("recipe_setpoints", {})
        cfg = bundle.get("config", {})
        THRESH_MARGIN = cfg.get("THRESHOLD_MARGIN", THRESH_MARGIN)
        SORT_MIN      = cfg.get("SORT_MIN", SORT_MIN)
        SORT_DEFAULT  = cfg.get("SORT_DEFAULT", SORT_DEFAULT)
        SORT_MAX      = cfg.get("SORT_MAX", SORT_MAX)
    else:
        press_model = bundle["press_ratio"]
        glaze_model = bundle["glaze_ratio"]
        kiln_model  = bundle["kiln_ratio"]
        stage_features = {
            "press_ratio": ["vol_start","pressure_psi","recipe_id"],
            "glaze_ratio": ["recipe_id","vol_press_out","pressure_psi"],
            "kiln_ratio":  ["recipe_id","vol_glaze_out","max_temp","cooling_profile","moisture_pct","external_humidity","air_flow_top_setting","air_cooling","thickness_mm"]
        }
        recipe_setpoints = {}
    return True

def _sp_for(rid):
    try:
        return recipe_setpoints.get(int(rid), {})
    except Exception:
        return {}

def _feature_row(feats, d, suppl=None):
    row={}
    src = dict(d)
    if suppl: src.update(suppl)
    sp = _sp_for(src.get("recipe_id"))
    for f in feats:
        if f in src and src[f] is not None and not (isinstance(src[f], float) and math.isnan(src[f])):
            row[f] = src[f]; continue
        if f.startswith("k_set_"):
            row[f] = sp.get(f, math.nan); continue
        if f.startswith("delta_"):
            base = f.replace("delta_","")
            set_key = "k_set_"+base if not base.startswith("k_set_") else base
            m = src.get(base, math.nan)
            s = sp.get(set_key, math.nan)
            try:
                row[f] = float(m) - float(s)
            except Exception:
                row[f] = math.nan
            continue
        row[f] = math.nan
    return row

def _df_for(stage_key, d, suppl=None):
    feats = stage_features.get(stage_key, [])
    return pd.DataFrame([_feature_row(feats, d, suppl)])

def _round0(x):
    try: return int(round(float(x)))
    except: return None

def predict(payload):
    d = payload
    res = {
      "stages": {
        "start":{"status":"blocked","amount":None,"min_required":None,"ratio":1.0},
        "press":{"status":"blocked","amount":None,"min_required":None,"ratio":None},
        "glaze":{"status":"blocked","amount":None,"min_required":None,"ratio":None},
        "kiln" :{"status":"blocked","amount":None,"min_required":None,"ratio":None},
        "sort" :{"status":"blocked","amount":None,"min_required":None,"ratio":SORT_DEFAULT}
      }
    }
    # START
    if d.get("vol_start") is None or (isinstance(d.get("vol_start"), float) and math.isnan(d.get("vol_start"))):
        return res
    start = float(d["vol_start"])
    res["stages"]["start"].update(status="actual", amount=_round0(start))

    # PRESS
    press_actual = d.get("vol_press_out")
    if press_actual is not None and not (isinstance(press_actual,float) and math.isnan(press_actual)):
        press_amt = min(float(press_actual), start)
        res["stages"]["press"].update(status="actual", amount=_round0(press_amt))
        press_base = press_amt
    else:
        df_press = _df_for("press_ratio", d)
        pr = float(press_model.predict(df_press)[0])
        press_amt = min(start * pr, start)
        min_req = start * max(0.0, pr - THRESH_MARGIN)
        res["stages"]["press"].update(status="pred", amount=_round0(press_amt), min_required=_round0(min_req), ratio=pr)
        press_base = press_amt

    # GLAZE
    glaze_actual = d.get("vol_glaze_out")
    if glaze_actual is not None and not (isinstance(glaze_actual,float) and math.isnan(glaze_actual)):
        glaze_amt = min(float(glaze_actual), press_base)
        res["stages"]["glaze"].update(status="actual", amount=_round0(glaze_amt))
        glaze_base = glaze_amt
    else:
        df_glaze = _df_for("glaze_ratio", d, {"vol_press_out": press_base})
        gr = float(glaze_model.predict(df_glaze)[0])
        glaze_amt = min(press_base * gr, press_base)
        min_req = press_base * max(0.0, gr - THRESH_MARGIN)
        res["stages"]["glaze"].update(status="pred", amount=_round0(glaze_amt), min_required=_round0(min_req), ratio=gr)
        glaze_base = glaze_amt

    # KILN
    kiln_actual = d.get("vol_kiln_out")
    if kiln_actual is not None and not (isinstance(kiln_actual,float) and math.isnan(kiln_actual)):
        kiln_amt = min(float(kiln_actual), glaze_base)
        res["stages"]["kiln"].update(status="actual", amount=_round0(kiln_amt))
        kiln_base = kiln_amt
    else:
        df_kiln = _df_for("kiln_ratio", d, {"vol_glaze_out": glaze_base})
        kr = float(kiln_model.predict(df_kiln)[0])
        kiln_amt = min(glaze_base * kr, glaze_base)
        min_req = glaze_base * max(0.0, kr - THRESH_MARGIN)
        res["stages"]["kiln"].update(status="pred", amount=_round0(kiln_amt), min_required=_round0(min_req), ratio=kr)
        kiln_base = kiln_amt

    # SORT (rule)
    sr = float(SORT_DEFAULT)
    sort_amt = min(kiln_base * sr, kiln_base)
    min_req = kiln_base * max(SORT_MIN, sr - 0.02)
    res["stages"]["sort"].update(status="pred", amount=_round0(sort_amt), min_required=_round0(min_req), ratio=sr)
    return res
      `;
      await pyodide.runPythonAsync(pyCode);
      $('statusText').textContent = 'Python ready. Loading model…';
      await autoLoadModel();
    }catch(e){
      $('statusText').textContent = 'Python failed to load.';
      logDebug(e.toString());
    }
  }

  async function autoLoadModel(){
    try{
      const resp = await fetch(MODEL_URL, { cache: 'no-store' });
      if(!resp.ok) throw new Error('HTTP '+resp.status+' fetching '+MODEL_URL);
      const buf = await resp.arrayBuffer();

      try { pyodide.FS.mkdir('/tmp',{mode:0o777}); } catch(e){}
      try { pyodide.FS.unlink(MODEL_PATH); } catch(e){}
      pyodide.FS.writeFile(MODEL_PATH, new Uint8Array(buf));

      await pyodide.runPythonAsync(`load_model("${MODEL_PATH}")`);
      modelLoaded = true;
      $('statusText').textContent = 'Model loaded ✅ (ml_model.joblib)';
      logDebug('Model loaded from '+MODEL_URL);
    }catch(e){
      modelLoaded = false;
      $('statusText').textContent = 'Could not load ml_model.joblib. Place it next to this HTML and open via http(s).';
      logDebug(e.toString());
    }
  }

  async function predictNow(){
    if(!modelLoaded){ $('statusText').textContent = 'Model not loaded.'; return; }

    // Dynamically collect all field values, convert numbers, leave strings as-is
    const payload = {};
    fields.forEach(k => {
      const el = $(k);
      if (!el) { payload[k] = null; return; }
      let val = el.value;
      if (val === '') { payload[k] = null; return; }
      // Determine if field should be numeric
      // If input type is number, or id starts with 'vol_' or is a known numeric field
      if (
        el.type === 'number' ||
        [
          'gloss_amount_target_g_per_tile',
          'vol_start','vol_press_out','vol_glaze_out','vol_kiln_out','vol_sort_out',
          'target_pressure','actual_pressure','layers_tossed','desired_thickness',
          'recipe_air_cooling','recipe_moisture','recipe_air_flow','recipe_max_temp','recipe_humidity',
          'kiln_air_cooling','kiln_moisture','kiln_air_flow','kiln_max_temp','kiln_humidity',
          'delta_air_cooling','delta_moisture','delta_air_flow','delta_max_temp','delta_humidity'
        ].includes(k)
      ) {
        const n = Number(val);
        payload[k] = isNaN(n) ? null : n;
      } else {
        payload[k] = val;
      }
    });

    let resObj;
    try{
      const pyPredict = pyodide.globals.get('predict');
      const pyPayload = pyodide.toPy(payload);
      const pyOut = pyPredict(pyPayload);
      resObj = pyOut.toJs({ dict_converter: Object.fromEntries });
      pyPayload.destroy(); pyOut.destroy(); pyPredict.destroy();
    }catch(e){
      $('statusText').textContent='Prediction failed. Check inputs.';
      logDebug('Predict error: '+e.toString());
      return;
    }

    const d = resObj.stages;
    const vols = [d.start.amount, d.press.amount, d.glaze.amount, d.kiln.amount, d.sort.amount];
    const mins = [d.start.min_required, d.press.min_required, d.glaze.min_required, d.kiln.min_required, d.sort.min_required];
    const statuses = ['start','press','glaze','kiln','sort'].map(k=>{
      const s = d[k].status; return s==='blocked'?'future':(s==='actual'?'actual':'pred');
    });

    setBadges([statuses[0],statuses[1],statuses[2],statuses[3]]);
    updateChart(vols, mins, statuses);

    const hints=[];
    if(statuses[1]==='future') hints.push('Press needs target_pressure and/or actual Press output.');
    if(statuses[2]==='future') hints.push('Glaze needs recipe_air_cooling/moisture/air_flow or actual Glaze output.');
    if(statuses[3]==='future') hints.push('Kiln benefits from kiln temp/cooling/moisture/humidity/air settings — but will impute if missing.');
    $('inputHint').textContent = hints.join(' ');
    $('statusText').textContent = 'Done.';
  }

  // ---------- Example: random stage, only fill up to that stage ----------
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function randFloat(a,b){ return a + Math.random()*(b-a); }

  function clearAll(){
    fields.forEach(id=>setVal(id,''));
  }

  function loadExample(){
    // Always ensure Start section is populated and not reset after
    // random recipe id from dropdown
    const ids = [241,244,245,246,247];
    const rid = ids[Math.floor(Math.random()*ids.length)];
    // random stage: 0 Start only, 1 Up to Press, 2 Up to Glaze, 3 Up to Kiln
    const stageIdx = Math.floor(Math.random()*4);
    // base start volume
    const start = randInt(56000, 90000);

    // Example datetime in "mm/dd/yyyy, --:-- --" locale-friendly format
    const dt = new Date(Date.now() - randInt(0, 7*24*60*60*1000));
    // Format as mm/dd/yyyy, hh:mm AM/PM
    function formatDateLocal(dt) {
      // Using en-US for mm/dd/yyyy, 12-hour
      return dt.toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
      });
    }
    // Set Start section required fields first
    setVal('datetime', dt.toISOString().slice(0,16)); // set input, but will show as local in field
    setVal('recipe_id', rid);
    setVal('gloss_type', ['shiny','matte','satin'][randInt(0,2)]);
    setVal('gloss_amount_target_g_per_tile', randFloat(10, 25).toFixed(1));
    setVal('vol_start', start);

    // Now clear all other fields except Start section
    // Only clear fields that are NOT Start section
    const startFields = [
      'datetime', 'recipe_id', 'gloss_type', 'gloss_amount_target_g_per_tile', 'vol_start'
    ];
    fields.forEach(id => {
      if (!startFields.includes(id)) setVal(id, '');
    });

    // Optional inputs and "actuals" up to the chosen stage
    if(stageIdx >= 1){
      setVal('vol_press_out', Math.round(start * randFloat(0.987, 0.994)));
      setVal('target_pressure', Math.round(randFloat(3000, 3200)));
      setVal('actual_pressure', Math.round(randFloat(2950, 3250)));
      setVal('layers_tossed', randInt(0, 2));
      setVal('desired_thickness', randFloat(7.5, 8.5).toFixed(2));
    }
    if(stageIdx >= 2){
      setVal('vol_glaze_out', Math.round(Number($('vol_press_out').value) * randFloat(0.988, 0.993)));
      setVal('recipe_air_cooling', randFloat(4.5, 5.5).toFixed(2));
      setVal('recipe_moisture', randFloat(5.8, 6.2).toFixed(2));
      setVal('recipe_air_flow', randFloat(5.5, 6.5).toFixed(2));
      setVal('recipe_max_temp', randInt(1190, 1200));
      setVal('recipe_humidity', randInt(45, 55));
    }
    if(stageIdx >= 3){
      setVal('vol_kiln_out', Math.round(Number($('vol_glaze_out').value) * randFloat(0.958, 0.969)));
      setVal('kiln_air_cooling', randFloat(4.5, 5.5).toFixed(2));
      setVal('kiln_moisture', randFloat(5.8, 6.2).toFixed(2));
      setVal('kiln_air_flow', randFloat(5.5, 6.5).toFixed(2));
      setVal('kiln_max_temp', randInt(1190, 1200));
      setVal('kiln_humidity', randInt(45, 55));
      setVal('delta_air_cooling', randFloat(-0.5, 0.5).toFixed(2));
      setVal('delta_moisture', randFloat(-0.2, 0.2).toFixed(2));
      setVal('delta_air_flow', randFloat(-0.3, 0.3).toFixed(2));
      setVal('delta_max_temp', randFloat(-2, 2).toFixed(2));
      setVal('delta_humidity', randFloat(-5, 5).toFixed(2));
      setVal('vol_sort_out', Math.round(Number($('vol_kiln_out').value) * randFloat(0.89, 0.92)));
    }

    // Always set Start badge and ensure blocked status if not predicted yet
    setBadges(['blocked','blocked','blocked','blocked']);

    // Show the Start datetime in a locale-friendly way in the status if desired
    const labels = ['Start only','Up to Press','Up to Glaze','Up to Kiln'];
    $('statusText').textContent = `Example loaded: ${labels[stageIdx]} (ID ${rid}, Start ${formatDateLocal(dt)}). Click Predict.`;
  }

  // Events
  document.getElementById('btnPredict').addEventListener('click', predictNow);
  document.getElementById('btnReset').addEventListener('click', resetAll);
  document.getElementById('btnExample').addEventListener('click', loadExample);

  // Boot
  resetAll();
  initPy();

  // once python and model load, auto-run example + predict
  window.addEventListener('load', async () => {
    // wait briefly to ensure Pyodide and model finish loading
    let checkCount = 0;
    const waitForModel = setInterval(() => {
      if (typeof modelLoaded !== 'undefined' && modelLoaded) {
        clearInterval(waitForModel);
        loadExample();    // fill example values
        setTimeout(predictNow, 500);  // predict after a short delay
      } else if (++checkCount > 50) {
        clearInterval(waitForModel);
        console.warn('Model did not load within expected time.');
      }
    }, 200);
  });
</script>
</body>
</html>