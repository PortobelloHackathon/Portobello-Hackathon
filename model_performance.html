<script>
/* ========= helpers & chart setup ========= */
const STAGES=['Start','Press','Glaze','Kiln','Sort'];
const $=id=>document.getElementById(id);
const fmt=n=>Number.isFinite(n)?n.toLocaleString():'–';
const pct=x=>Number.isFinite(x)?x.toFixed(2)+'%':'–';
const PB_GRAY_L='#CFD3DA';

const lossChart=new Chart($('wfLine').getContext('2d'),{
  type:'line',
  data:{labels:STAGES,datasets:[
    {label:'Predicted',data:[],borderWidth:2,tension:0.3,borderColor:'#7E22CE',pointBackgroundColor:'#7E22CE',pointRadius:4},
    {label:'Min Threshold',data:[],borderDash:[6,6],borderWidth:1.5,borderColor:'#F59E0B',pointRadius:3}
  ]},
  options:{responsive:true,maintainAspectRatio:false,
    scales:{x:{grid:{display:false}},y:{beginAtZero:true,grid:{color:PB_GRAY_L}}},
    plugins:{tooltip:{callbacks:{
      title:(it)=>'Stage '+(it[0].dataIndex+1)+' — '+STAGES[it[0].dataIndex],
      label:(it)=>fmt(it.parsed.y)+' ft²'
    }}}}
});

/* ========= python & model ========= */
let pyodide,modelLoaded=false;
async function initPy(){
  $('wfStatus').textContent='Loading Python…';
  pyodide=await loadPyodide();
  await pyodide.loadPackage(['numpy','pandas','scikit-learn','joblib']);
  const code=`${/* inject working predictor from stage demo */''}
import math, joblib, pandas as pd, numpy as np
bundle=None
press_model=glaze_model=kiln_model=None
THRESH_MARGIN=0.03; SORT_MIN=0.90; SORT_DEFAULT=0.90
def load_model(p):
  global bundle,press_model,glaze_model,kiln_model
  bundle=joblib.load(p)
  press_model=bundle['models']['press_ratio']
  glaze_model=bundle['models']['glaze_ratio']
  kiln_model=bundle['models']['kiln_ratio']
  return True
def predict(d):
  r={'stages':{s:{'status':'blocked','amount':None,'min_required':None} for s in ['start','press','glaze','kiln','sort']}}
  vstart=float(d.get('vol_start',0) or 0)
  if not vstart: return r
  r['stages']['start'].update(status='actual',amount=int(vstart))
  pr=float(press_model.predict(pd.DataFrame([{'vol_start':vstart}]))[0])
  press=vstart*pr; r['stages']['press'].update(status='pred',amount=int(press),min_required=int(vstart*(pr-THRESH_MARGIN)))
  gr=float(glaze_model.predict(pd.DataFrame([{'vol_press_out':press}]))[0])
  glaze=press*gr; r['stages']['glaze'].update(status='pred',amount=int(glaze),min_required=int(press*(gr-THRESH_MARGIN)))
  kr=float(kiln_model.predict(pd.DataFrame([{'vol_glaze_out':glaze}]))[0])
  kiln=glaze*kr; r['stages']['kiln'].update(status='pred',amount=int(kiln),min_required=int(glaze*(kr-THRESH_MARGIN)))
  sort=kiln*SORT_DEFAULT; r['stages']['sort'].update(status='pred',amount=int(sort),min_required=int(kiln*(SORT_MIN)))
  return r
`;
  await pyodide.runPythonAsync(code);
  const buf=await (await fetch('ml_model.joblib',{cache:'no-store'})).arrayBuffer();
  try{pyodide.FS.mkdir('/tmp');}catch{}
  pyodide.FS.writeFile('/tmp/ml_model.joblib',new Uint8Array(buf));
  await pyodide.runPythonAsync('load_model("/tmp/ml_model.joblib")');
  modelLoaded=true;
  $('wfStatus').textContent='Model loaded ✅';
}
initPy();

/* ========= compute & chart update ========= */
function autoDeltas(){
  const r=['air_cooling','moisture','air_flow','max_temp','humidity'];
  r.forEach(x=>{
    const rv=Number($('wf_recipe_'+x).value),kv=Number($('wf_kiln_'+x).value);
    if(!isNaN(rv)&&!isNaN(kv))$('wf_delta_'+x).value=(kv-rv).toFixed(2);
  });
}
function payload(){
  autoDeltas();
  const p={};
  document.querySelectorAll('#panel-whatif input,#panel-whatif select').forEach(el=>{
    let v=el.value;
    if(el.type==='number'||el.id.startsWith('wf_')){v=Number(v);if(isNaN(v))v=null;}
    p[el.id.replace('wf_','')]=v;
  });
  return p;
}
async function runWF(){
  $('wfStatus').textContent='Predicting…';
  const pl=payload();
  if(!pl.vol_start){$('wfHint').textContent='Enter a start volume';return;}
  let res;
  if(modelLoaded){
    const f=pyodide.globals.get('predict');
    const pyIn=pyodide.toPy(pl);
    const pyOut=f(pyIn);
    res=pyOut.toJs();pyIn.destroy();pyOut.destroy();f.destroy();
  }else{ // fallback
    const s=pl.vol_start,v=[s,s*0.98,s*0.97,s*0.95,s*0.89];
    res={stages:{start:{amount:v[0]},press:{amount:v[1]},glaze:{amount:v[2]},kiln:{amount:v[3]},sort:{amount:v[4]}}};
  }
  const st=res.stages;
  const vols=[st.start.amount,st.press.amount,st.glaze.amount,st.kiln.amount,st.sort.amount];
  const mins=[st.start.min_required,st.press.min_required,st.glaze.min_required,st.kiln.min_required,st.sort.min_required];
  lossChart.data.datasets[0].data=vols;
  lossChart.data.datasets[1].data=mins;
  lossChart.update();
  const y=(vols[4]/vols[0])*100;
  $('wfHint').textContent=`Final yield ≈ ${pct(y)} (${fmt(vols[4])} ft² of ${fmt(vols[0])})`;
  $('wfStatus').textContent='Done ✅';
}
$('wfRun').addEventListener('click',runWF);
</script>