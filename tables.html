<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tables — Portobello Dashboard</title>

  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet" />

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter','ui-sans-serif','system-ui'] },
          colors: {
            pbBlue: '#0B1F52',
            pbSlate: '#6B7280',
            pbGrayLight: '#CFD3DA',
            pbGrayMid: '#7C8390',
            pbGrayDark: '#434A52'
          }
        }
      }
    }
  </script>
</head>

<body class="h-screen flex flex-col bg-slate-50 text-slate-800 font-sans">
  <!-- HEADER -->
  <header class="bg-gradient-to-r from-pbGrayLight via-pbGrayMid/80 to-pbBlue">
    <div class="relative w-full py-5 pl-3 flex items-center">
      <a href="/" class="shrink-0">
        <img src="assets/images/logo_portobello_america_CORES_pantone_655.png" alt="Portobello America" class="h-16 w-auto object-contain block" />
      </a>
      <h1 class="absolute left-1/2 -translate-x-1/2 text-white text-xl md:text-2xl lg:text-4xl font-semibold tracking-tight text-center pointer-events-none">
        Tile Material Dashboard
      </h1>
      <div class="ml-auto"></div>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden">
    <script src="sidebar.js" defer></script>
    <main class="flex-1 overflow-auto">
      <div class="mx-auto max-w-[1400px] px-6 md:px-8 py-8">
        <div class="flex items-center justify-between">
          <h2 class="text-3xl font-semibold tracking-tight text-slate-900">Tables</h2>
          <div id="dataStatus" class="text-sm text-slate-500"></div>
        </div>

        <!-- FILTERS -->
        <section class="mt-5 rounded-2xl border border-slate-200 bg-white shadow-sm p-4">
          <div class="flex flex-wrap gap-3 items-end">
            <div>
              <label class="block text-xs text-slate-600 mb-1">Search</label>
              <input id="q" type="text" placeholder="Find in any column…" class="border rounded p-2 w-64" />
            </div>
            <div>
              <label class="block text-xs text-slate-600 mb-1">Recipe</label>
              <select id="fRecipe" class="border rounded p-2 w-44 bg-white">
                <option value="">All recipes</option>
              </select>
            </div>
            <div>
              <label class="block text-xs text-slate-600 mb-1">Known up to</label>
              <select id="fStage" class="border rounded p-2 w-48 bg-white">
                <option value="">Any</option>
                <option value="start">Start only</option>
                <option value="press">Up to Press</option>
                <option value="glaze">Up to Glaze</option>
                <option value="kiln">Up to Kiln</option>
                <option value="sort">Full (Includes Sort)</option>
              </select>
            </div>
            <div>
              <label class="block text-xs text-slate-600 mb-1">Datetime</label>
              <div class="flex gap-1">
                <input id="fDatetimeStart" type="datetime-local" class="border rounded p-2 w-36" placeholder="From" />
                <span class="px-1 text-slate-500">–</span>
                <input id="fDatetimeEnd" type="datetime-local" class="border rounded p-2 w-36" placeholder="To" />
              </div>
            </div>
            <div>
              <label class="block text-xs text-slate-600 mb-1">Rows per page</label>
              <select id="pageSize" class="border rounded p-2 w-36 bg-white">
                <option>10</option>
                <option selected>20</option>
                <option>50</option>
                <option>100</option>
              </select>
            </div>
            <div class="ml-auto flex gap-2">
              <button id="btnResetFilters" class="px-3 py-2 rounded border">Reset filters</button>
              <button id="btnExport" class="px-3 py-2 rounded bg-pbBlue text-white">Export filtered CSV</button>
            </div>
          </div>

          <div class="mt-4 border-t pt-3">
            <span class="text-xs text-slate-600 mr-3">Column groups:</span>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="meta" checked /> Meta
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="start" checked /> Start
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="press" checked /> Press
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="glaze" checked /> Glaze
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="kiln" checked /> Kiln
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="sort" checked /> Sort
            </label>
            <label class="inline-flex items-center mr-4 text-sm">
              <input type="checkbox" class="groupToggle mr-2" data-group="loss_yield" checked /> Loss / Yield
            </label>
          </div>
        </section>

        <!-- TABLE -->
        <section class="mt-5 rounded-2xl border border-slate-200 bg-white shadow-sm p-0 overflow-hidden">
          <div class="overflow-auto">
            <table class="w-full text-sm">
              <thead class="sticky top-0 z-10 bg-slate-50 text-slate-700">
                <tr id="theadGroups" class="border-b"></tr>
                <tr id="theadCols" class="border-b"></tr>
                <tr id="theadFilters" class="bg-white/70"></tr>
              </thead>
              <tbody id="dataTableBody"></tbody>
            </table>
          </div>
          <div class="flex items-center justify-between px-4 py-3 border-t bg-white">
            <div id="pageInfo" class="text-sm text-slate-600"></div>
            <div class="flex gap-2">
              <button id="prevPage" class="px-3 py-1.5 rounded border disabled:opacity-50">Prev</button>
              <button id="nextPage" class="px-3 py-1.5 rounded border disabled:opacity-50">Next</button>
            </div>
          </div>
        </section>
        <p id="warnMissing" class="mt-3 text-sm text-amber-700"></p>
      </div>
    </main>
  </div>

  <script>
const COLS = [
  {
    group: 'meta', label: 'Meta',
    cols: [
      { key: 'datetime', label: 'Datetime', type: 'string', width: 'w-[180px]' },
      { key: 'recipe_id', label: 'Recipe ID', type: 'number', width: 'w-[90px]' },
      { key: 'gloss_type', label: 'Gloss Type', type: 'string', width: 'w-[130px]' },
      { key: 'gloss_amount_target_g_per_tile', label: 'Gloss Target (g/tile)', type: 'number', width: 'w-[160px]' },
    ]
  },
  { group: 'start', label: 'Start', cols: [{ key: 'vol_start', label: 'Start ft²', type: 'number', width: 'w-[120px]' }] },
  { group: 'press', label: 'Press', cols: [
      { key: 'vol_press_out', label: 'Press Out ft²', type: 'number', width: 'w-[140px]' },
      { key: 'target_pressure', label: 'Target Pressure', type: 'number', width: 'w-[130px]' },
      { key: 'actual_pressure', label: 'Actual Pressure', type: 'number', width: 'w-[130px]' },
      { key: 'layers_tossed', label: 'Layers Tossed', type: 'number', width: 'w-[120px]' },
      { key: 'desired_thickness', label: 'Desired Thickness (mm)', type: 'number', width: 'w-[160px]' },
    ]
  },
  { group: 'glaze', label: 'Glaze', cols: [{ key: 'vol_glaze_out', label: 'Glaze Out ft²', type: 'number', width: 'w-[140px]' }] },
  { group: 'kiln_recipe', label: 'Recipe / Targets', cols: [
      { key: 'recipe_air_cooling', label: 'Recipe Air Cooling', type: 'number' },
      { key: 'recipe_moisture', label: 'Recipe Moisture', type: 'number' },
      { key: 'recipe_air_flow', label: 'Recipe Air Flow', type: 'number' },
      { key: 'recipe_max_temp', label: 'Recipe Max Temp (°C)', type: 'number' },
      { key: 'recipe_humidity', label: 'Recipe Humidity %', type: 'number' },
    ]
  },
  { group: 'kiln_actual', label: 'Kiln Actuals', cols: [
      { key: 'kiln_air_cooling', label: 'Kiln Air Cooling', type: 'number' },
      { key: 'kiln_moisture', label: 'Kiln Moisture', type: 'number' },
      { key: 'kiln_air_flow', label: 'Kiln Air Flow', type: 'number' },
      { key: 'kiln_max_temp', label: 'Kiln Max Temp (°C)', type: 'number' },
      { key: 'kiln_humidity', label: 'Kiln Humidity %', type: 'number' },
    ]
  },
  { group: 'delta', label: 'Delta vs Recipe', cols: [
      { key: 'delta_air_cooling', label: 'Δ Air Cooling', type: 'number' },
      { key: 'delta_moisture', label: 'Δ Moisture', type: 'number' },
      { key: 'delta_air_flow', label: 'Δ Air Flow', type: 'number' },
      { key: 'delta_max_temp', label: 'Δ Max Temp (°C)', type: 'number' },
      { key: 'delta_humidity', label: 'Δ Humidity %', type: 'number' },
    ]
  },
  { group: 'kiln', label: 'Kiln Output', cols: [{ key: 'vol_kiln_out', label: 'Kiln Out ft²', type: 'number' }] },
  { group: 'sort', label: 'Sort', cols: [{ key: 'vol_sort_out', label: 'Sort Out ft²', type: 'number' }] },
  { group: 'loss_yield', label: 'Loss / Yield', cols: [
      { key: 'loss_press', label: 'Loss Press %', type: 'number' },
      { key: 'loss_glaze', label: 'Loss Glaze %', type: 'number' },
      { key: 'loss_kiln', label: 'Loss Kiln %', type: 'number' },
      { key: 'loss_sort', label: 'Loss Sort %', type: 'number' },
      { key: 'yield_total', label: 'Yield Total %', type: 'number' },
      { key: 'yield_total_target', label: 'Yield Target %', type: 'number' },
    ]
  },
];

    // visible group state
    const groupVisible = { meta:true, start:true, press:true, glaze:true, kiln:true, sort:true };

    // ---------------- Utilities ----------------
    const $ = (id) => document.getElementById(id);
    const fmt = (v) => (v == null || v === '' || Number.isNaN(v)) ? '—' :
      (typeof v === 'number' ? (Number.isInteger(v) ? v.toLocaleString() : v.toLocaleString(undefined, { maximumFractionDigits: 3 })) : String(v));

    function toNumber(val) {
      if (val === null || val === undefined || val === '') return NaN;
      const n = Number(String(val).replace(/,/g, ''));
      return Number.isFinite(n) ? n : NaN;
    }

    function parseCSV(text) {
      const lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n').filter(l=>l.trim()!=="");
      if (lines.length === 0) return { columns: [], rows: [] };
      const parseLine = (line) => {
        const res = []; let cur=''; let inQ=false;
        for (let i=0;i<line.length;i++){
          const ch=line[i];
          if(ch==='"'){
            if(inQ && line[i+1]==='"'){ cur+='"'; i++; }
            else inQ=!inQ;
            continue;
          }
          if(ch===',' && !inQ){ res.push(cur); cur=''; continue; }
          cur+=ch;
        }
        res.push(cur);
        return res;
      };
      const headers = parseLine(lines[0]).map(h => h.trim());
      const rows = lines.slice(1).map(l => {
        const parts = parseLine(l);
        const obj = {};
        for (let i=0;i<headers.length;i++) obj[headers[i]] = (parts[i] !== undefined ? parts[i].trim() : '');
        return obj;
      });
      return { columns: headers, rows };
    }

    // heuristic furthest-known stage for a row
    function stageLevel(r) {
      const has = (k) => r[k] != null && r[k] !== '' && !Number.isNaN(toNumber(r[k]));
      if (has('vol_sort_out')) return 'sort';
      if (has('vol_kiln_out')) return 'kiln';
      if (has('vol_glaze_out')) return 'glaze';
      if (has('vol_press_out')) return 'press';
      if (has('vol_start')) return 'start';
      return '';
    }

    // ---------------- State ----------------
    let raw = { columns: [], rows: [] };
    let typedRows = [];              // numeric columns parsed
    let filtered = [];               // after filters
    let visibleCols = [];            // flattened visible column definitions
    let sortKey = 'datetime';
    let sortDir = 'asc';
    let page = 1;
    let pageSize = 20;

    // ---------------- Build headers ----------------
    function buildHeaders() {
      // group header
      const theadGroups = $('theadGroups');
      const theadCols   = $('theadCols');
      const theadFilters= $('theadFilters');
      theadGroups.innerHTML = '';
      theadCols.innerHTML   = '';
      theadFilters.innerHTML= '';

      const makeTH = (html, extra='') => `<th class="px-3 py-2 text-left text-[12px] font-semibold ${extra}">${html}</th>`;
      const sortIcon = (key) => {
        if (key !== sortKey) return '';
        return sortDir === 'asc'
          ? '<span class="inline-block ml-1 align-middle select-none">▲</span>'
          : '<span class="inline-block ml-1 align-middle select-none">▼</span>';
      };

      // group row
      const groupCells = [];
      visibleCols = []; // reset
      COLS.forEach(group => {
        if (!groupVisible[group.group]) return;
        const cols = group.cols.filter(c => true);
        if (cols.length === 0) return;
        groupCells.push(`<th class="px-3 py-2 text-left text-xs font-semibold text-slate-600 border-r" colspan="${cols.length}">${group.label}</th>`);
        visibleCols.push(...cols.map(c => ({ ...c, groupKey: group.group })));
      });
      theadGroups.innerHTML = groupCells.join('');

      // column row (click to sort)
      visibleCols.forEach(col => {
        const th = document.createElement('th');
        th.className = `px-3 py-2 text-left text-[12px] font-semibold whitespace-nowrap border-r ${col.width||''} cursor-pointer select-none`;
        th.dataset.key = col.key;
        th.innerHTML = `${col.label}${sortIcon(col.key)}`;
        th.addEventListener('click', () => {
          if (sortKey === col.key) sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
          else { sortKey = col.key; sortDir = 'asc'; }
          buildHeaders();
          runPipeline();
        });
        theadCols.appendChild(th);
      });

      // filter row (simple per-column text inputs)
      visibleCols.forEach(col => {
        const th = document.createElement('th');
        th.className = `px-3 py-1 text-left text-xs border-r ${col.width||''}`;
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.placeholder = 'filter…';
        inp.className = 'border rounded p-1 w-full text-xs';
        inp.dataset.key = col.key;
        inp.addEventListener('input', runPipeline);
        th.appendChild(inp);
        theadFilters.appendChild(th);
      });
    }

    // ---------------- Filters & Sorting ----------------
    function collectColumnFilters() {
      const obj = {};
      document.querySelectorAll('#theadFilters input').forEach(inp => {
        const k = inp.dataset.key;
        const v = (inp.value || '').trim();
        if (v) obj[k] = v.toLowerCase();
      });
      return obj;
    }

    function applyFilters() {
      const q = ($('q').value || '').toLowerCase();
      const rid = $('fRecipe').value;
      const stage = $('fStage').value;
      // Datetime range filter
      const dtStartRaw = $('fDatetimeStart').value;
      const dtEndRaw = $('fDatetimeEnd').value;
      let dtStart = null, dtEnd = null;
      if (dtStartRaw) {
        // Parse as UTC if possible
        dtStart = new Date(dtStartRaw.length === 16 ? dtStartRaw + ':00Z' : dtStartRaw + 'Z');
        if (isNaN(dtStart)) dtStart = new Date(dtStartRaw);
      }
      if (dtEndRaw) {
        // Parse as UTC if possible
        dtEnd = new Date(dtEndRaw.length === 16 ? dtEndRaw + ':00Z' : dtEndRaw + 'Z');
        if (isNaN(dtEnd)) dtEnd = new Date(dtEndRaw);
      }
      const colFilters = collectColumnFilters();

      filtered = typedRows.filter(r => {
        if (rid && String(r.recipe_id) !== rid) return false;
        if (stage) {
          const lv = stageLevel(r);
          if (lv !== stage) return false;
        }
        // Datetime range filter
        if ((dtStart || dtEnd) && r.datetime) {
          // Parse r.datetime as ISO 8601, always UTC
          let rowDate = new Date(r.datetime);
          if (isNaN(rowDate)) return false;
          // If start specified, must be >= start
          if (dtStart && rowDate < dtStart) return false;
          // If end specified, must be <= end
          if (dtEnd && rowDate > dtEnd) return false;
        }
        // If range is specified but r.datetime missing, skip
        if ((dtStart || dtEnd) && !r.datetime) return false;

        // global search
        if (q) {
          let hit = false;
          for (const k in r) {
            const val = r[k];
            if (val == null || val === '') continue;
            if (typeof val === 'number') {
              if (String(val).toLowerCase().includes(q)) { hit = true; break; }
            } else if (String(val).toLowerCase().includes(q)) { hit = true; break; }
          }
          if (!hit) return false;
        }

        // per-column small filter
        for (const k in colFilters) {
          const needle = colFilters[k];
          const v = r[k];
          const hay = (v == null) ? '' : String(v).toLowerCase();
          if (!hay.includes(needle)) return false;
        }

        return true;
      });
    }

    function applySort() {
      const dir = (sortDir === 'asc' ? 1 : -1);
      filtered.sort((a, b) => {
        const ka = a[sortKey], kb = b[sortKey];
        if (ka == null && kb == null) return 0;
        if (ka == null) return 1;
        if (kb == null) return -1;

        // numeric vs string
        if (typeof ka === 'number' && typeof kb === 'number') {
          return (ka - kb) * dir;
        }
        // try numeric compare if both look numeric
        const na = Number(ka), nb = Number(kb);
        if (Number.isFinite(na) && Number.isFinite(nb)) {
          return (na - nb) * dir;
        }
        // fallback lexicographic
        return String(ka).localeCompare(String(kb)) * dir;
      });
    }

    function paginate() {
      const total = filtered.length;
      const pages = Math.max(1, Math.ceil(total / pageSize));
      if (page > pages) page = pages;
      const start = (page - 1) * pageSize;
      const end = Math.min(start + pageSize, total);
      const rows = filtered.slice(start, end);
      $('pageInfo').textContent = `${start + 1}–${end} of ${total}`;
      $('prevPage').disabled = (page <= 1);
      $('nextPage').disabled = (page >= pages);
      return rows;
    }

    // ---------------- Render ----------------
    function renderTableRows(rows) {
      const tbody = $('dataTableBody');
      const cellsHTML = (r) => visibleCols.map(col => {
        const v = r[col.key];
        const cls = (typeof v === 'number') ? 'text-right' : 'text-left';
        const muted = (v == null || v === '' || Number.isNaN(v)) ? 'text-slate-400' : '';
        let displayVal = v;
        if (col.key === 'datetime' && v) {
          const d = new Date(v.includes('T') ? v : v.replace(' ', 'T'));
          if (!isNaN(d)) {
            displayVal = d.toLocaleString('en-US', {
              month: 'short',
              day: 'numeric',
              year: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
            });
          }
        }
        return `<td class="px-3 py-2 border-t ${cls} ${muted}">${fmt(displayVal)}</td>`;
      }).join('');

      tbody.innerHTML = rows.map(r => {
        // highlight row if any key stage is missing (optional)
        const missingKeyStage = (r.vol_press_out==null && r.vol_glaze_out==null && r.vol_kiln_out==null && r.vol_sort_out==null);
        const bg = missingKeyStage ? 'bg-yellow-50' : 'bg-white';
        return `<tr class="${bg} hover:bg-slate-50">${cellsHTML(r)}</tr>`;
      }).join('');
    }

    function runPipeline() {
      // page size may change
      pageSize = Number($('pageSize').value) || 20;
      applyFilters();
      applySort();
      const pageRows = paginate();
      renderTableRows(pageRows);
    }

    // ---------------- Init / Data load ----------------
    async function init() {
      // load CSV
      try {
        const txt = await fetch('tiles.csv', { cache: 'no-store' }).then(r => r.text());
        raw = parseCSV(txt);
        $('dataStatus').textContent = `${raw.rows.length} rows loaded`;

        // Determine numeric columns from the current schema
        // Always include known numeric columns, but also add any new columns that match vol_*_out or other numeric-like fields
        const baseNumKeys = [
          'recipe_id','vol_start','pressure_psi','vol_press_out','vol_glaze_out',
          'max_temp','cooling_profile','moisture_pct','external_humidity',
          'air_flow_top_setting','air_cooling','thickness_mm','vol_kiln_out','vol_sort_out'
        ];
        // Add any columns in tiles.csv that look like new numeric outputs (e.g. future vol_x_out columns)
        const extraNumKeys = raw.columns.filter(c =>
          /^vol_.*_out$/.test(c) && !baseNumKeys.includes(c)
        );
        // Also add any other columns in the schema that are not in baseNumKeys but look numeric (e.g. end in _pct, _mm, _psi, _setting)
        const moreNumKeys = raw.columns.filter(c =>
          !baseNumKeys.includes(c) &&
          (/_pct$|_mm$|_psi$|_setting$|_temp$|_humidity$|_flow$|_cooling$|_thickness$/.test(c))
        );
        const numKeys = new Set([...baseNumKeys, ...extraNumKeys, ...moreNumKeys]);

        // Numeric conversion for all numeric columns
        typedRows = raw.rows.map(r => {
          const o = { ...r };
          for (const k of numKeys) {
            if (k in r) o[k] = toNumber(r[k]);
          }
          // keep datetime string as-is
          return o;
        });

        // Fill filter options
        // Use only recipes that are finite numbers
        const ridSet = Array.from(new Set(typedRows.map(r => r.recipe_id).filter(v => Number.isFinite(v)))).sort((a,b)=>a-b);
        $('fRecipe').innerHTML = '<option value="">All recipes</option>' + ridSet.map(v => `<option value="${v}">${v}</option>`).join('');

        // Datetime filter: no longer needed (was dropdown)

        // Build headers (visible groups)
        buildHeaders();
        runPipeline();

      } catch (e) {
        $('dataStatus').textContent = 'Error loading tiles.csv';
        $('warnMissing').textContent = String(e);
      }
    }

    // ---------------- Events ----------------
    $('q').addEventListener('input', () => { page = 1; runPipeline(); });
    $('fRecipe').addEventListener('change', () => { page = 1; runPipeline(); });
    $('fStage').addEventListener('change', () => { page = 1; runPipeline(); });
    $('fDatetimeStart').addEventListener('change', () => { page = 1; runPipeline(); });
    $('fDatetimeEnd').addEventListener('change', () => { page = 1; runPipeline(); });
    $('pageSize').addEventListener('change', () => { page = 1; runPipeline(); });
    $('prevPage').addEventListener('click', () => { if (page > 1) { page--; runPipeline(); }});
    $('nextPage').addEventListener('click', () => { page++; runPipeline(); });

    // group toggles
    document.addEventListener('change', (e) => {
      if (!e.target.classList.contains('groupToggle')) return;
      const g = e.target.dataset.group;
      groupVisible[g] = e.target.checked;
      buildHeaders();
      runPipeline();
    });

    $('btnResetFilters').addEventListener('click', () => {
      $('q').value = '';
      $('fRecipe').value = '';
      $('fStage').value = '';
      $('fDatetimeStart').value = '';
      $('fDatetimeEnd').value = '';
      document.querySelectorAll('#theadFilters input').forEach(i => i.value = '');
      page = 1;
      runPipeline();
    });

    // Export filtered CSV
    $('btnExport').addEventListener('click', () => {
      // ensure current filtered is up-to-date
      applyFilters(); applySort();
      // CSV header = visible columns only
      const cols = visibleCols.map(c => c.key);
      const header = visibleCols.map(c => c.label);
      const lines = [header.join(',')];
      filtered.forEach(r => {
        const row = cols.map(k => {
          const v = r[k];
          const s = (v == null || Number.isNaN(v)) ? '' : (typeof v === 'number' ? v : String(v));
          // escape if needed
          return /[",\n]/.test(String(s)) ? '"' + String(s).replace(/"/g,'""') + '"' : String(s);
        });
        lines.push(row.join(','));
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tiles_filtered.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // go!
    init();
  </script>
</body>
</html>